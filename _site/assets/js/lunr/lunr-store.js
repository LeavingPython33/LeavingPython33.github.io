var store = [{
        "title": "3D-Printed Hydroponic Tower",
        "excerpt":"Features   Cost, Time, and Materials   Science Behind It   Hydroponic System Timeline   Hydroponic System In-Action  ","categories": ["Engineering","Gardening"],
        "tags": ["3D-Printing"],
        "url": "/portfolio/3DP_Hydroponics/",
        "teaser": "/assets/img/Tower.jpg"
      },{
        "title": "Agendly",
        "excerpt":"Demonstration                                                                                                                                                                                    Screenshots from Agendly       Inspiration  As students, most of us are accustomed to using different Learning Management System (LMS)s. One LMS that many of us used prior to coming to Vanderbilt is Canvas. Canvas has a really great tool that allows you to export your test and assignment dates to calendar softwares, which helps students stay on top of things. One pain point in Vanderbilt’s main LMS, Brightspace, is that there’s currently no such functionality. We wanted to make the process easier than manually adding every date from every syllabus to your calendar of choice. We then realized that this kind of technology can be used to turn any text agenda into convenient Google Calendar action items!   What it does  Users log in with their Google Account and are prompted to upload an agenda as a .pdf or .docx file. The program then calls on an LLM to process that text and generate a set of event objects. These are then displayed to the user to allow for edits and any correction needed. The user is then provided with the option to automatically sync these with their Google Calendar or download an .ics file that can be uploaded to Google, Apple, and Notion calendars.   How we built it  We used Auth.JS to let users log in with Google. For the web app, we used Next.JS 14 with TypeScript and TailWindCSS to create an interactive user interface that lets them upload and download .pdf or .docx files. The Mammoth library was used to convert these text files into plain text. Then, we used the Vercel AI SDK with OpenAI as our model provider (we used GPT-4o for this project) to process this text and generate structured JSON objects that our app displayed and allowed users to edit. We then used a JavaScript function to convert the JSON objects into an .ics file that users could download directly to their computer or sync to their Google Calendar using the Google Calendar API.   Challenges we ran into  When it came to the underlying LLM task, building on the Vercel AI SDK usually means responding to text with more plain text. However, our project required us to get an LLM to take in text data, break it down into a series of calendar objects, and return it in a specific .ics format. To do this, we had to experiment with different forms of output supported by the Vercel AI SDK, specifically generating a structured object that follows a certain schema, and then formatting it to fit ICS format. During the construction of the actual app, having to display these event objects and allowing the user to edit them was one of our biggest roadblocks. For integration with Google/Google Calendar, we initially wanted to use Auth0 but the authentication with the Google Calendar API wasn’t available. Therefore, we had to switch to using Auth.JS and learn how to handle JWT tokens and login state management.   Accomplishments that we’re proud of  We used a REAL Vandy Systems Physiology syllabus and our program was able to successfully parse it and generate test and homework deadlines! We were then able to successfully sync them to Google Calendar with one-click and download the events as an ICS file and upload them to our Apple and Notion calendars!   What we learned  Aside from learning about full-stack web development, we learned how to work with the Vercel AI SDK and use Zod schema to structure JSON outputs.   What’s next for Agendly  We’re looking at three main avenues of improvement: First, one initiative we began but didn’t have time to finish was integration with various LMS so that students can directly connect their classes to their calendars. We were planning on webscraping using Python and Selenium to log into an LMS and scrape the syllabus off of every course page. This can help save even more time for our students, as they don’t have to upload their separate syllabi. Secondly, we’d like to add a tab on the user’s page that saves all the uploaded agendas so they can be redownloaded for convenience. We would ideally use MongoDB to store the IDs and .ICS files associated with each user’s text files. Secondly, because we’re using a general GPT-4o model to turn event information into calendar files, Agendly can be used for all kinds of agendas! We would like to test it on other kinds of agendas besides syllabi (for clubs, companies, or really anyone who has meetings, because who doesn’t …)   Built With     nextjs   openai   typescript   Source Code   Github Repository   ","categories": ["Technology","Coding","Website"],
        "tags": ["Nextjs","Openai","Typescript"],
        "url": "/portfolio/Agendly/",
        "teaser": "https://d112y698adiu2z.cloudfront.net/photos/production/software_photos/003/053/202/datas/medium.jpg"
      },{
        "title": "DIY Aquaponics Systems ",
        "excerpt":"Features     Grows vegetables using nutrients from the fish poo   Passive filter for the aquarium water   Self-Sustainable   Cost, Time, and Materials     Cost: About $200   Time: About 1 month   Materials Needed:                  Materials       Amount                       Water Pump (~400gal/h)       1                 20 Gal Aquarium       1                 Grow Lights       1                 Leca Grow Medium       1                 Planter Box       1                 PVC Pipes       ~~~                 Different PVC Pipe Angles       ~~~                 Caulk       1                 Bell Siphon (3D-Printed)       1           Science Behind It   Aquaponics Timeline   CAD Model   Aquaponics In-Action  ","categories": ["Engineering","Gardening"],
        "tags": ["CAD","3D-Printing"],
        "url": "/portfolio/DIY_Aquaponics/",
        "teaser": "/assets/img/Aquaponics.jpg"
      },{
        "title": "FRC 2023",
        "excerpt":"Features   My Role   CAD Model   Our Robot In-Action  ","categories": ["Engineering","Robotics"],
        "tags": ["CAD","Electrical","Mechanical"],
        "url": "/portfolio/FRC%202023/",
        "teaser": "/assets/img/Robot.png"
      },{
        "title": "HomeLab (Home server)",
        "excerpt":"Features     Create Virtual Machines (VMS) for any reason   Able to access the Server from anywhere with an internet access, by using reverse proxy/tunnel   Able to host different web services and servers like Minecraft servers, website pages, and homebrew google photos   Cost and Time  The cost depends on whether you want to use your older desktops or build one for the purpose of running a home server. However, the most important components for the home server to run, is the CPU that can run VMs and have multiple cores. Another important component is the RAM, I recommend atleast or more than 32GB to run several VMs and services.   The amount of time in setting up the home server relies on whether you’re tech savvy, as it requires a lot of navigating through bios and reading forums in solving your issues.   Steps For Setting Up My HomeLab   Setting Up The HyperVisor  The HyperVisor allows the user to create multiple VMs on a single system making the system more versatile.   The general steps in setting up a HyperVisor:      Wipe all the files on the old desktop   Install the HyperVisor OS on a thumbdrive (for my server I used ProxMox)   Plug the thumbdrive into the desktop and go into BIOs (Don’t forget to activate CPU VMs!!!)   Boot up the thumbdrive OS   Follow the steps in setting up the HyperVisor onto the main drive (If you have a GPU disable it, as HyperVisor crash when interacting with GPUs)   After setting up the HyperVisor it will host a dashboard on the local network   Use your own personal device to open the dashboard with the ip they provided   General Steps for Creating VMs  There isn’t any one way in creating VMs, as there’s a lot of OS that need different specification. However, the first steps is to upload your osi to your HyperVisor.   Setting Up The Reverse Proxy  If you aren’t in one place at all times, you might want your home server accessible anywhere. However, exposing your local network to the internet can allow hackers to have access to your local network so we have to use reverse proxy services like Nginx and Cloudflare to protect yourself.   This YouTube Video shows how to open a reverse proxy with Cloudflare:     But with anything involving exposing your network there comes with a risk, SO DO IT AT YOUR OWN RISK!!   HomeLab Dashboards  This is the following information you’ll find in your HyperVisor Dashboard:     Server Specs   Server Load   VM Specs   VM Load   Network Traffic   Storage   Shell   The information will help you diagnose or find any problem in your server. However, if you have a lot of different services with different ips and site name you’ll have to create your own dashboard to easily navigate all of them. For my home server I use Homer to create a static webpage to easily access my home server services.      My Homer Dashboard   Whats Next  Currently I’m hosting Video Game servers, but I hope to host experimental websites that utilizes my server for the back-end of the websites.  ","categories": ["Computer","VMS"],
        "tags": ["IT","Proxmox","Cloudflare"],
        "url": "/portfolio/HomeLab/",
        "teaser": "https://vivid-cow-9924242169.media.strapiapp.com/cloudflare_bb657624dc.webp"
      },{
        "title": "MultiMaterial-Pliers",
        "excerpt":"Project Overview  This project showcases a fully 3D-printed, print-in-place pliers design that requires no special tools to assemble. Print-in-place technique allow for detailed mechanisms, such as hinges, gears, and springs, to be printed in one job without post-processing. It also allows for the mechanisms to be encased which wouldn’t be possible without the print-in-place technique.   Print-in-place designs have been used in various applications, including:     Articulated toys (e.g., flexi dragons, snakes, octopus)   Mechanical tools (wrenches, pliers, adjustable clamps)   Mechanical demonstration (gears, bearings, joints)   Household items (foldable hinges, bottle openers)   For a succesful Print-in-place job, you have to carefully consider the material selected to ensure smooth movement, durability, and minimal post-processing. The best materials depends on the type of mechanism (hinges, gears, springs, etc.) and whether you’re using a single material or multi-material printing.   Most Popular Material for FDM     PLA (Polylactic Acid)            ✅ Pros: Easy to print, rigid, good for gears and interlocking parts       ❌ Cons: Brittle over time, poor flexibility (can snap on thin hinges)       Best for: Low-stress PIP designs (e.g., articulated toys, simple hinges)           PETG (Polyethylene Terephthalate Glycol)            ✅ Pros: More flexible than PLA, better layer adhesion, impact-resistant       ❌ Cons: Slightly stringy, requires tuning for bridging       Best for: Functional tools (pliers, wrenches) where slight flex is needed           TPU (Thermoplastic Polyurethane, 95A or softer)            ✅ Pros: Extremely flexible, excellent for springs and snap-fit parts       ❌ Cons: Difficult to print (needs slow speeds, direct drive extruder)       Best for: Living hinges, grippers, compliant mechanisms           ABS (Acrylonitrile Butadiene Styrene)            ✅ Pros: High strength &amp; durability, heat-resistant, slightly flexible       ❌ Cons: Prone to warping, Fumes &amp; ventilation needed, tricky layer adhesion, not as elastic as TPU       Best for: High-stress PIP parts (e.g., tool handles, mechanical latches), applications needing heat resistance (e.g., automotive, outdoor use)           Embedded CAD Model    Design &amp; Iterative   Pliers Specifications     Total Width: 89mm   Total Length: 137mm   Spring Mechanism   The pliers feature an integrated a hinge spring, allowing the jaws to return to their default position. The spring was designed with:     Holes for snap-fitting the handles and jaws   Clearence between the jaws for more degree of movement   Flat bottom and top for advanced slicing in creating the spring form   Jaw Specification     Jaw Length: 56mm   Jaw Width: 18.4mm   Jaw Thickness: 6.6mm   Jaw Capacity: 13mm (Relaxed)   Has hooks for snap-fit   Handle Specification     Handle Length: 80mm   Handle Width: 18mm   Handle Thickness: 6.6mm   Has hooks for snap-fit   Material Selection     PLA            For rigidity in the jaws and handles           TPU            For spring effect in the flexible section of the mult-material pliers       Allows for snap-fit with PLA           Key Iterations     First Iteration – First print of handles, jaw, and spring mechanism, but snap-fit joint and jaw print failed   Second Iteration – Deeper hole joint on PLA part, more hook joints on the spring mechanism, and thicker parts for better snap-fit. Plier couldn’t close all the way due to long handles. Plier also had a weak grip due to spring mechanism’s low infill (10%)   Final Design – Fix spring mechanism’s infill to have enough tension, shortened the handles, and change jaw shape for better grip on resistors.   Print Settings     Printer: FDM (Voron)   Nozzle: 0.6   Flexible Part Settings     Material: TPU   Infill: 15%   Fill Pattern: Rectilinear   Bottom Solid Layers: 0   Top Solid Layers: 0   Perimeters Count: 4   Handle and Jaw Settings     Material: PLA   Infill: 25%   Fill Pattern: Gyroid   Bottom Solid Layers: 3   Top Solid Layers: 4   Perimeters Count: 2   Gallery: Iterations &amp; Final Plier                                                                          Iterations and Final Plier       GIF: Pliers in Action     ","categories": ["Engineering","Additive Manufacturing"],
        "tags": ["CAD","FDM"],
        "url": "/portfolio/MultiMaterial_Plier/",
        "teaser": "/assets/img/plier/Final.JPG"
      },{
        "title": "Syringe Pump Project",
        "excerpt":"Introduction  Syringe pumps are motor-driven devices that are made to precisely and consistently transfer fluids with accuracy. They are used in several different scientific domains, such as biotechnology and pharmaceutical research for precise measurements and reproducible experiments due to their continuous and regulated fluid delivery. Syringe pumps main utility comes from their safe handling of biological materials, as they maintain sterility while swapping syringes. In addition, they precisely pump fluids of high viscosities while preserving a continuous flow. These pumps typically include a motor to power the mechanism, a syringe holder to safely hold the fluid, and a push block to enable the plunger to move smoothly and under control. These parts work together as the fundamental building blocks of a syringe pump, giving researchers and practitioners more precision and control over their experiments.   Parts Required   Off-the-shelf parts                  Part Name       Amount                       V-Slot 20x40x350       1                 NEMA-17-Motor       1                 Coupler       1                 M3x6mm Bolt       4                 Lead Screw TR8x8x250mm       1                 M3x10mm Bolt       4                 M5x8mm Bolt       10                 M5 Tee Nut       10                 Linear Rod 8mmx200mm       1                 LM8UU Linear Bearing       1                 Nut tr8x8-4       1                 M3x6mm Bolt       4                 F688ZZ Flanged Ball Bearing       2                 8mm Lock Collar for Lead Screw       2                 8mm Lock Collar for Linear Rod       2                 91290A113 Alloy Steel Socket Head Screw       2                 Arduino Uno       1                 Breadboard       1                 rq-65 Power Supply       1                 Potentiometer       1                 LED 10mm       1                 10mm Latching Push Button Switch       1                 Wires for Breadboard       —           3D-printed parts                  Part Name       Amount                       Motor Mount       1                 Carriage       1                 End Support Plunger End       1                 End Support Nozzle End       1                 Base       1                 Top       1                 Front       1           Design Constraints  The goal of this project is to design a functional syringe pump while meeting several design constraints. First, the pump must be driven by a stepper motor coupled to a lead screw, and the flow rate (in mL/min) should be easily adjustable through an Arduino program. This includes using global variables for the flow rate and syringe pump diameter, allowing for decimal values. The pump needs to be compatible with syringes of different diameters (20 mL to 10 mL), with tool-free switching between syringes. The motor mounts should be printed using ABS. The outside of the stepper motor can reach up to 80 C and ABS does not deflect until 100 C. Additionally, the syringe should be supported at both ends to prevent sagging during operation.   The design must also include an LED indicator to show the pump’s operational state: green for running, yellow for paused, and red for empty. A latching button should control the start and pause of the pump’s motion, while a limit switch must stop the motion when the plunger reaches its limit. Electrical wiring must be clean, with proper terminations and protected soldered joints. Custom wire harnesses should be created for external buttons and sensors, while jumper wires are used only for breadboard-to-breadboard and breadboard-to-Arduino connections.   To protect parts and users, electrical components must be shielded from liquids and user interference. Core components should be assembled as a single unit, with the electronics enclosure attached to the syringe pump. Unique branding is encouraged to distinguish the pump from other models, and components should be joined using fasteners or non-permanent snap fits, avoiding glue or hammering.   Additional features such as motor movement direction control buttons and a potentiometer for flow rate control should be included. The pump should use the AccelStepper library for motor control, ensuring smooth speed transitions and precise flow rate control. Custom 3D printed parts are required for mounting the motor, holding the syringe, and enclosing the electronics while adhering to safety measures around handling the power supply and preventing electrical hazards. Lastly, the pump’s Arduino code should control the stepper motor speed, manage LED indicators, and account for flow rate conversion.   Instructions on Operating Syringe Pump     Flash the arduino with the SyringePumpProgram.ino file if not already   Turn on the power supply by plugging it into a 120 V outlet   Push the latching button to active the syringe pump, the led on the front board will turn green to indicate that it’s on   Watch the syringe pump pump at a specific flow rate (mL/m)   You can pause the syringe pump by clicking on the latching button again and the led will turn yellow to indicate that the syringe pump is paused   When the syringe is empty, it’ll hit the limit switch. The limit switch will stop the syringe and make the led red to inform you that it’s empty.   Push the latching to turn off the syringe pump   Reset the syringe pump and do it all over again   If you want to change the flow rate go in the .ino file and change the flowRate global variable or you can manually change the flow rate with the potentiometer on the front   Design Coverage      Figure 1. Syringe Pump CAD rendering      Figure 2. Syringe Pump Physical Model   The system utilizes a stepper motor coupled to a threaded rod in order to pump fluid in and out of the syringe. The motor is fastened to a 3D printed ABS motor mount with four M4 bolts which in turn is also bolted down to the 2040 aluminum extrusion. The motor setup is seen below in Figure 3.      Figure 3. Motor setup   The syringe is set up across three components along the actuator: the carriage, the plunger holder, and the nozzle support. All three parts are 3D PLA parts. The plunger holder and nozzle support are secured to the aluminum extrusion, while the carriage remains unfastened as shown below in Figure 4.       Figure 4. Syringe Setup   A lead screw with an 8mm lead is embedded into the carriage while bearings are placed in the plunger holder and nozzle support to facilitate linear actuation when the motor turns. A linear rod is sent through all three parts to stabilize the carriage with collars placed to prevent the rod from sliding. The carriage has an inlet cut out for the plunger flange to grip the syringe. Similarly, the plunger holder has an inlet to grip the barrel flange and the nozzle holder has a concave opening to prevent the nozzle from sagging. There is also a limit switch embedded into the plunger holder that closes when the syringe is empty. This occurs when the carriage reaches a certain distance from the plunger holder.   This design is compatible for multiple diameter syringes, as the carriage includes an opening larger than the plungers but smaller than the plunger flanges. The plunger holder follows a similar approach, providing an opening sufficiently large for the barrels while small enough to secure the flange. This accommodation can be seen in Figure 5 below.       Figure 5. Dual Syringe Setup   The button on the syringe pump acts as a start and stop switch. When the button is not pressed, the LED will be yellow, indicating that the pump is in a paused state. Pressing the button turns the LED green, signaling that the pump is active and in a “go” state. Activation of the limit switch turns the LED red and sends a signal to the Arduino, indicating that the syringe has fully pumped out. The red LED also signifies that the syringe is empty and in a stopped mode. Turning the potentiometer counterclockwise increases the pumping speed, and vice versa. Pressing the momentary button on the left causes the syringe to retract, while pressing the button on the right causes the syringe to extrude. The full user interface is shown below in Figure 6 with the wiring diagram in Figure 7.      Figure 6. User interface      Figure 7. Wiring Diagram   The base of the syringe pump protects the electronic components from any water and humans, by fully covering the arduino, breadboard, and power supply. The top piece of the base is designed to hold the syringe pump mechanism, but also to protect all the electronics from water and fingers. The front piece of the base holds all the buttons for the user and hides all the electronics from the user. The base width is smaller than the T-extrusion so if the syringe has any water leaks, the water will spill outside the base. The base also has vents to protect the power supply from overheating.   The syringe pump is programmed by the Arduino IDE, because it’s easier to compile and upload the program into the Arduino Uno than any other programs. The Arduino IDE includes many libraries, which were used to easily program the stepper motor. The library that was used to program the syringe pump is called AccelStepper. In configuring the motor, the direction must be set to high for clockwise motion. We used all available microstepping, resulting in sixteenth-step resolution microstepping. The high microstepping allows the stepper motor to be more precise in pushing out the fluids, which is important in giving the correct dosage. If you want to change the flow rate of the syringe or turn off some of the functions, you can change the following variables in Figure 8.                  Variable       Data                       bool extraCred       True/False if you want the left and right button to be active                 const int microStep       The microStep fraction (if it’s 1/16 steps, input 16)                 const int diameter       The diameter of the syringe in mm                 const int leadScrew       Lead screw travel distance for every full rotation                 double flowRate       Desired flow rate in mL/min                 bool dynamic       True/False if you want potentiometer to control flow rate           Figure 8. Important Variables in SyringePumpProgram.ino   Operating Limits  The theoretical max flow rate for any syringe size that can be inputted into the program is 320000 steps per second which is 1.36 * 10^10 mL/min, because the max speed set on the stepper motor is 320000 steps per second. The smallest volume of fluid that can be dispensed is 0 mL because the syringe pump can be slowed down to a flow rate of 0 mL/min with the potentiometer or in the flowRate variable. The smallest flow rate that is non zero is 0.043 mL/min, because the stepper motor’s smallest speed is 1 step per second. The range between the maximum and minimum flow rates should be enough in a medical setting, as you don’t want to dispense too slow or too fast.   Calculations in Converting Volumetric Flow Rate to Steps  For the syringe project, the desired flow rate needs to be converted from mL/min to steps per second for the stepper motor to use. The equation to turn flow rate into steps per second is:   flowRate (mL/min)* 1min60s1000mm31mL1r2(mm2)1revleadScrew(mm)200 * microStep (steps)1rev=stepPerSec (st/s)   Example     Lets input a flow rate of 1 mL/min, the diameter of the syringe to 19mm, no micro stepping, and 8mm lead screw   Set the flow rate to seconds so divide the flow rate by 60 seconds = 1/60 (ml/s)   Multiply the flow rate by 1000mm^3/1mL, so the flow rate in terms of mm^3 is = 1000/60 (mm^3/s)   Calculate the area of the syringe by inputting 19mm into (d/2)2  to get 283.53 mm^2   Then divide the flow rate by the syringe’s area to get the flow rate’s speed in one axis = 5.88e-2 mm/s   Take the speed and divide it by the lead screw (8mm) to get the amount of revolution it needs to take = 7.35e-3 rev/s   Take the distance travel per full rotation and multiply it by the amount of steps it takes for the stepper motor make a full rotation including microstepping will get us  7.35e-3 rev/s * 200 * 1 = 1.47 steps/s   The program will set the speed of the stepper motor to 1.47 Steps/s to produce 1 mL/min in a syringe with a diameter of 19mm   Conclusion  In conclusion, this project provided the opportunity to determine whether designing, manufacturing, wiring, and coding a syringe pump from scratch is a cost-effective alternative to commercial products, while having comparable performance. Throughout the project, there were several different challenges that were encountered and addressed. Manufacturing wise, there were many issues that were encountered whether it was a flipped sketch or a wrong dimension, which required the part to be printed again. This delay in the timeline pushed back testing code and electronics. Software wise, there were a lot of small mistakes from putting the wrong pin numbers, incorrect if statements, or not executing the right function. The mistake in the software had to go through thorough testing, removing time off from the paper. Looking back on the project, it was key that the team tested far in advance to prevent work out any kinks. Future improvement could include customizing the length of the aluminum base, threaded rod, and linear rod for a streamlined design. Overall, the project demonstrated a valid proof of concept with the given materials and displayed the potential of a budget friendly and high performance syringe pump.   Appendix A.  Arduino Code (SyringPumpProgram.ino)   Github Repository   The following variables of the program                  Variable       Data                       bool extraCred       True/False if you want the left and right button to be active                 bool empty       True if the syringe is empty, else false                 const int limitSwitchPin       The limit switch pin number                 const int buttonPin       The On/Off button pin number                 const int potPin       The potentiometer pin number                 const int rgbPin[]       The LED RGB pin numbers (array)                 const int leftButtonPin       The left button pin number                 const int rightButtonPin       The right button pin number                 const int microStep       The microStep fraction (e.g., input 16 for 1/16 steps)                 const int diameter       The diameter of the syringe in mm                 const int leadScrew       Lead screw travel distance for every full rotation                 double flowRate       Desired flow rate in mL/min                 double syringeSpeed       The syringe’s speed in mm/s                 double stepPerSec       Syringe’s speed converted to steps/s                 int prevPotVal       Tracks the potentiometer value                 bool dynamic       True/False if you want the potentiometer to control flow rate           The following functions of the program                  Function       Description                       void setup()       Sets up the pin modes for switches and LEDs. Initializes the stepper motor with a set speed.                 void loop()       Runs the overall program, tracking switch values and responding accordingly.                 void computeSteps(double flow)       Computes the steps per second based on the given flow rate.                 void writeLed(int rgb[])       Writes the RGB pins with values from the rgb[] array.           Syringe Pump CAD    Drawings                                                                                                                                      Syringe Pump Drawings      ","categories": ["Engineering","Digital Fabrication"],
        "tags": ["CAD","3D-Printing","Electrical","Mechanical"],
        "url": "/portfolio/SyringePumpProject/",
        "teaser": "/assets/img/syringe/image4.png"
      },{
        "title": "Ukulele",
        "excerpt":"Features   My Role   CAD Model   Our Robot In-Action  ","categories": ["Engineering"],
        "tags": ["CAD","Mechanical"],
        "url": "/portfolio/Ukulele/",
        "teaser": "/assets/img/Ukulele.png"
      },{
        "title": "μFluidic Device",
        "excerpt":"Introduction   What are μFluidic Devices?  A μfluidic (microfluidic) device is like a circuit board for liquids, designed to precisely control and manipulate small volumes of fluids, often at the micrometer scale. These devices use a network of tiny channels, valves, and pumps to direct fluid flow, similar to how electrical circuits control the movement of electrons. Microfluidic devices are widely used in medical diagnostics, DNA sequencing, tissue engineering, and environmental testing.   What is pinch flow fractionation?  Pinch Flow Fractionation (PFF) is a microfluidic technique used to separate particles based on their size by estimating the particles position through a narrowing (pinch) region. In a PFF device theres two inlet channels, one carrying the particles and another acting as a sheath flow—merge and enter a pinch region. The sheath flow directs smaller particles closer to the channel walls while larger particles remain near the center due to their larger size. At the end of the PFF device there’s multiple outlet channels that collects the separated particles based on their flow trajectories and for the sheat flow. PFF can be used for isolating and analysing biological particles such as cells, viruses, and extracellular vesicles.   Application of μFluidic Device Sorting  μFluidic are used for for clinical and therapeutic applications. Microfluidic sorting allows for the separation of specific cell populations, which is important for cell therapy. In this Article they used Microfluidic sorting to separate and recover stem cells from bonemarrow aspirates for the purpose of manufacturing stem cell therapy. Stem cell therapy is a medical treatment that uses stem cells to repair or replace damaged or diseased tissues.   Instructions   CAD Model  The PFF is designed based on the given particle sizes, as it’s used to determine where the outlet channels should be positioned at. For CADing the pinch and broad region, it’s preferable to have a big ratio between them for effective sorting. The height of channels shouldn’t be too big that particles start to stack, inhibiting the sorting process. The outlets should have similar flow rate to prevent the potential of back flow, where a big particle might get sucked in to a high flow rate small particle outlet channel. The flow rate of a channel is determined by its length and width.       For my CAD model I created the biggest broad region possible and the smallest pinch possible to create a big ratio for effective sorting. To ensure equal flow rate I created outlets with different width and length to prevent potential backflow.   Print and Cure Mold  The PFF should be printed on a resin printer to ensure the small channels are preserved from the CAD model   Desired Printer Specifications:     Laser Spot Size (i.e., Minimum Feature Size): 85 μm   Minimum XY Resolution: 25 μm   Minimum Z Resolution: 25 μm   Build volume: (145 × 145 × 185) mm   Post Processing Steps:     Wash the device for 5 minutes on the print bed in the FormWash and then remove it from the bed and wash it for another 5 minutes in fresh IPA (the stationary bath to right of the FormWash). Do not exceed 15 total minutes of wash time as the resin can absorb the IPA.   Let your device dry by leaning it upside down for 30 minutes before curing. Do not let the IPA pool inside the device while drying. Confirm that the inside of the mold has a homogenous sheen. Glossy areas indicate that uncured resin is still present, which will inhibit the crosslinking of PDMS.   DO NOT TOUCH THE INSIDE OF UNCURED MOLD. Using your finger or paper towel to remove uncured resin will increase the surface roughness of the mold. This roughness will transfer to the PDMS device, likely causing sealing issues.   Gently blow off any debris between your μFluidic’s channels. With safety glasses on, use compressed air to dislodge any foreign particles/resin that may have been picked up during the washing step.   Perform a 60 second surface cure with supports on. Curing the model for long durations can cause it to warp. Further, the mold does not require robust mechanical properties to function. Therefore, we will cure either the black or high-temp resin for 60 seconds at room temperature (no heat).   Remove support material. Once again be careful not to touch the inside of the mood.      Resin Print of PFF Device   Parylene Device  The PFF mold must be coated with a protective layer because the resin could leech into the cast PDMS causing incomplete features and curing.   The solution is parlyene coating process. The parylene coating process is a way to apply a very thin, protective layer to 3D printed parts.   The Parylene Process:     Clean the 3D print: The part is cleaned to remove dust or oils.   Place in a vacuum chamber: The 3D print goes into a special vacuum chamber.   Vaporize the parylene: Parylene is heated and turned into a gas inside the chamber.   Coating forms: The gas cools and forms a thin, even layer on the 3D print.   Solidify: The coating hardens, creating a protective surface.   Cast PDMS  For casting the mold we use Polydimethylsiloxane (PDMS), which is an elastomeric (i.e., rubber-like) thermoset that is mixed together and poured into the mold.   PDMS Steps     SYLGARDTM 184 Silicone Elastomer (10:1 mix ratio)   Heat cure times:   24 hours at 23°C, or 4 hours at 65°C, or 1 hour at 100°C, or 15 minutes at 150°C   Please note: clear resin (Form 4) will crack at 100C      Cast of PFF Device   Plasma Bond Glass Slide  The microfluidics needs a glass slide wall to allow viewing of the sorting process. However, glass is very inert and glue is a viable option, as it can fill the features.   The solution is Plasma bonding. Plasma bonding glass slides is a process that uses plasma (ionized gas) to make glass reactive and bond to other materials.   The Plasma Bonding Glass Slide Steps:     Clean the glass slide to remove dirt, oils, or contaminants using a solvent like isopropyl alcohol.   Place the glass slide inside a plasma chamber.   Activate the plasma by applying high voltage to gas (like oxygen or air) in the chamber, turning it into plasma.   The plasma reacts with the glass surface, etching it and increasing its surface energy for better adhesion.   After plasma treatment, the glass is ready to bond with other materials, as the surface is now cleaner and more reactive.   Press the glass onto the microfluidic device cast.      Plasma Cleaner         Plasma Bonding Process   Testing   Placeholder   Discussion      Why are resin-printed molds coated with parylene prior to casting the PDMS?     Uncured resin monomers can leach out of the printed device interfering the crosslinking of PDMS, which leads to incomplete curing.       What are hypothetical applications of your microfluidic mixer or sorter?     My microfluidic sorter could be used to sort blood samples for analysis or use of specific cells. Certain cells in the bloodstream can be used for therapies for people who lack a specific cell type, like stem cell therapy.       Why is your geometry conducive to sorting? Discuss specific dimensions (pinch width, outlet width, location of ports, etc.) My Chosen Geometry:         Broad Width: 19mm     Pinch Width: 0.6mm     Three Outlet Ports in a triangle formation with varying paths and width     Outlet Path Length: about 19mm     Two Inlet Ports with a width of 1.5mm       My chosen geometry is conducive to sorting, as it has a large ratio between the broad and pinch widths, promoting better PFF sorting. The outlets have varying paths and widths to prevent flow imbalances between them and stop backflow. Since the lengths of the outlets are the same, I had to change the outlet channel width to change the flow rate. The outlet width is determined by the size of the particles. Since the larger particles are about 2.5 times bigger than the smaller particles, the outlet for the larger particles should be 2.5 times wider.       Based on the results of testing, could you implement any future changes to improve sorting?     Based on the testing results, I would make the beginning of the broad width shorter to prevent eddy currents. In my testing, there were signs of eddy currents as some small particles kept moving around in circles, which slowed down the sorting process. Unfortunately, the testing for my PFF ended short, as there was a leak between the glass slide and cast.       Did you attempt the bonus opportunity? If so, describe your approach and success.     I didn’t attempt the bonus opportunity   ","categories": ["Engineering","Additive Manufacturing"],
        "tags": ["CAD","Resin-Printing"],
        "url": "/portfolio/%CE%BCFluidic/",
        "teaser": "/assets/img/ModelDevice.jpeg"
      },{
        "title": "RoboRepair",
        "excerpt":" ","categories": [],
        "tags": [],
        "url": "/videogames/RoboRepair/",
        "teaser": "https://img.itch.zone/aW1nLzEyNDQ3NTU3LnBuZw==/315x250%23c/gXXdSW.png"
      }]
